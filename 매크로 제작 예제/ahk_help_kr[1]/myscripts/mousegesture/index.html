<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<title>MouseGesture.ahk</title>
<link rel="stylesheet" href="../../css/default.css" type="text/css">

<style>

#index dd ul{
padding:0px!important;
margin:0px!important;
}


h2:before{
content: counter(chapter) ". ";
}
h2{
counter-increment:chapter;
counter-reset:section;
}

p{
	margin:0.5em;
}
h3:before{
content: counter(chapter) "." counter(section) ". ";
}
h3{
counter-increment:section;
}
img{
float:right;
margin-bottom:4px;
}

</style>

</head>
<body>
<div class="navi">→ <a target=_top href='../../index.html'>AutoHotkey(을)를 유행시키는 페이지</a> → <a target=_top href='../../myscripts/index.html'>My Scripts</a> → <a target=_top href='../../myscripts/mousegesture/index.html'>MouseGesture.ahk</a></div>

<h1>MouseGesture.ahk</h1>

<h2>개요</h2>
<p>「 오른쪽 버튼을 누르면서 커서를 위에 이동」이나 「 오른쪽 버튼을 누르면서 호이르크리크」와 같은 마우스 제스 차 기능을 실현하는 상주 스크립트.<br />
마우스 제스 차에는, 통상의 메뉴나 툴바를 이용한 마우스 조작과 비교해서, 작은 버튼 등에 커서를 맞출 필요가 없기 때문에, 커서 위치를 의식하는 일 없이 재빠르게 커멘드를 실행할 수 있다고 하는 이점이 있다.
</p>

<p>
본스크립트의 제스 차는, 버튼 눌러 내려 커서 이동, 버튼을 놓는 조작등의 편성으로 정의한다.<br />
동작 할당은, 어플리케이션등의 조건 마다 설정 가능.조건에는,AutoHotkey의 식을 사용할 수 있다.<br />
할당하는 동작은,AutoHotkey의 스크립트로 지정한다.<br />
제스 차, 조건별 할당의 조건, 동작의 할당 등은 설정 화면으로부터 실시할 수 있다.
</p>


<h2>다운로드</h2>
<p><a target=_top href='http://lukewarm.s101.xrea.com/myscripts/MouseGesture2.zip'>MouseGesture2.zip</a>
</p>

<a name="top"></a><h2>설명(목차)</h2>

<dl id="index">
<dt><a target=_top href='../../myscripts/mousegesture/index.html#basis'>기본적인 사용법</a></dt><dd><ul>
<li><a target=_top href='../../myscripts/mousegesture/index.html#install'>인스톨·업데이트</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#execute'>실행</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#target'>조건 정의</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#gesture'>제스 차 정의</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#action'>동작 할당</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#config'>그 외의 설정</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#screenedge'>화면단 접촉 인식</a></li>
</ul></dd>
<dt><a target=_top href='../../myscripts/mousegesture/index.html#target2'>고도의 조건 정의</a></dt><dd><ul>
<li><a target=_top href='../../myscripts/mousegesture/index.html#title'>타이틀의 부분 일치에 의한 윈도우의 판별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#commandline'>커멘드 라인 문자열에 의한 프로그램의 판별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#file'>타이틀에 의한 열려 있는 파일·페이지의 판별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#hittest'>윈도우의 부위의 판별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#cursor'>마우스 커서에 의한 부위의 판별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#controlrect'>같은 클래스의 컨트롤의 좌표에 의한 구별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#windowrect'>윈도우상의 커서 위치에 의한 판별</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#pos'>화면상의 좌표에 의한 판별</a></li>

<li><a target=_top href='../../myscripts/mousegesture/index.html#ini'>MouseGesture.ini의 직접 편집에 의한 설정</a></li>

</ul></dd>
<dt><a target=_top href='../../myscripts/mousegesture/index.html#gesture2'>고도의 제스 차 정의</a></dt><dd><ul>
<li><a target=_top href='../../myscripts/mousegesture/index.html#multibuttonstroke'>복수 버튼+스트로크</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#longstroke'>장거리 스트로크</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#multigesture'>연속 발동형 제스 차</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#longclick'>버튼을 중인방 해 크리크 했을 때에 발동</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#shortclick'>눌러 내리고 있는 시간이 짧은 크리크에 동작을 할당</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#buttonhold'>버튼을 「눌렀을 때」와「놓았을 때」에 실행</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#while'>버튼을 누르고 있는 동안 반복 발동</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#while2'>버튼 눌러 인하시, 누르고 있는 동안, 밀어 올려 때에 발동</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#hold2'>누르고 있는 버튼이 놓아졌을 때의 동작을 예약</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#defer'>모든 버튼이 놓아졌을 때에 발동하는 동작을 예약</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#timer'>버튼을 일정시간 계속 눌렀을 때에 발동</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#wait'>크리크와 더블 클릭에 각각 동작을 할당</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#wait2'>단독 더블 클릭 등, 도중에 모든 버튼이 놓아지는 제스 차</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#timer2'>더블 클릭과1회만의 크리크에 다른 동작을 할당</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#triple'>트리프르크리크 이상에의 할당</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#modkey'>수식 키와의 편성</a></li>
</ul></dd>
<dt><a target=_top href='../../myscripts/mousegesture/index.html#action2'>고도의 동작 할당</a></dt><dd><ul>
<li><a target=_top href='../../myscripts/mousegesture/index.html#timeout'>본래의 마우스 조작의 재현(타임 아웃 등)</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#movecursor'>커서 이동의 발생</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#scroll'>스크롤</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#dropfiles'>의사적으로 파일의 드롭을 발생시킨다</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#filestoclipboard'>파일을 크리프보드 경유로 페이스트</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#controlhiddenwindows'>비액티브나 비표시의 윈도우를 조작</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#counter'>실행할 때 마다2개의 동작을 교대로 반복한다</a></li>
</ul></dd>
<dt><a target=_top href='../../myscripts/mousegesture/index.html#script'>스크립트에 의한 커스터마이즈</a></dt><dd><ul>
<li><a target=_top href='../../myscripts/mousegesture/index.html#include'>타스크립트에의#Include에 의한 편입</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#hotkey'>메뉴의 커멘드를 hot key등에서 실행</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#userahk'>확장 스크립트</a></li>
<li><a target=_top href='../../myscripts/mousegesture/index.html#tooltip'>커스텀 툴 팁</a></li>
</ul></dd>
</dl>






<a name="basis"></a><h2>기본적인 사용법</h2>

<a name="install"></a><h3>인스톨·업데이트</h3>
<img src="0010.png" width="418" height="286" alt="(26213bytes)">
<p>MouseGesture.zip에 포함되는 파일·폴더는 아래와 같이 이다.<br />
AutoHotkey(을)를 인스톨 한 상태로MouseGesture.ahk(을)를 기동하면 사용할 수 있다.
</p>
<dl>
<dt>MG_Buttons\</dt><dd>버튼 정의 스크립트를 격납하는 폴더</dd>
<dt>MG_ScreenEdge\</dt><dd>화면단에의 접촉을 버튼으로서 취급하는 기능을 제공하는 파일군.사용 방법은, 안의readme.txt(을)를 참조.</dd>
<dt>MG_Config.ahk</dt><dd>설정을 바탕으로 생성된 스크립트</dd>
<dt>MG_Edit.ahk</dt><dd>설정 편집과MG_Config.ahk의 생성을 실시한다.통상은 메뉴로부터 호출한다.</dd>
<dt>MouseGesture.ahk</dt><dd>본체.통상은, 이 스크립트를 실행하는 일로 기동한다.</dd>
<dt>MG_User.ahk</dt><dd>추가의 스크립트를 기술하기 위한 파일.「확장 스크립트 편집」을 실행했을 때에 생성된다.</dd>
<dt>MouseGesture.ini</dt><dd>설정 정보를 보존해 두는 스크립트.설정을 보존한 시점에서 생성된다.</dd>

<dt>readme.txt</dt><dd>설명</dd>
</dl>
<p>
업데이트시는, 어카이브(archive)의 내용을 통째로 덧쓰기해 버려 상관없다.<br />
설정 정보가 기술된 「MouseGesture.ini」(이)나, 추가의 스크립트를 기술하는 「MG_User.ahk」(은)는, 배포 어카이브(archive)에는 포함되지 않기 때문에, 덧쓰기될 걱정은 없다.<br />
스크립트를 재기동하는 일로, 갱신 후의 스크립트를 사용할 수 있다.
</p>

<br clear="all" />

<a name="execute"></a><h3>실행</h3>
<img src="0210.png" width="314" height="192" alt="(5575bytes)">
<p>
실행하면 task tray에 아이콘이 표시되어 각종의 조작을 실시할 수 있다.<br />
각 커멘드의 개요는, 이하와 같다.<br />
아이콘 더블 클릭시에는, 「설정 편집」의 동작을 한다.
</p>


<dl>
<dt>유효</dt><dd>제스 차의 개시 트리거의 유효/무효를 변환</dd>
<dt>네비 표시</dt><dd>입력중 제스 차의 툴 팁 표시를 유효/무효화</dd>
<dt>확장 스크립트 편집</dt><dd>「MG_User.ahk」(을)를 에디터로 열린다</dd>
<dt>재기동</dt><dd>정의 스크립트를 재생성 후, 스크립트를 재기동한다</dd>
<dt>설정 편집</dt><dd>설정 화면을 연다</dd>
<dt>AutoHotkey</dt><dd>AutoHotkey의 표준 커멘드</dd>
</dl>
<p>
첫회 기동시에는 자동적으로 설정 화면이 표시된다.제스 차는 아무것도 등록되지 않기 때문에, 어떠한 제스 차를 등록할 필요가 있다.
</p>
<br clear="all" />


<a name="target"></a><h3>조건 정의</h3>
<p>
MouseGesture.ahk그럼, 대상 윈도우등의 조건에 따르고, 하나의 제스 차에 다른 동작을 할당할 수 있다.<br />
특정의 소프트에서만 할당을 유효하게 하고 싶은 경우나, 「통상은 윈도우를 닫는 조작, 탭형MDI의 소프트에서는 탭을 닫는 조작」이라고, 「통상은Ctrl+C(을)를, 카피가Alt+C의 소프트에서는Alt+C(을)를 송신」과 같이 닮은 동작을 할당하는 일을 상정하고 있다.<br />
같은 제스 차에 완전히 다른 동작을 할당하는 것은, 할당을 잊기 쉽상이 되므로 추천 되지 않는다.
</p>
<p>
통상은, 타겟 윈도우는 제스 차의 입력 개시시에 마우스 커서아래에 있던 윈도우, 타겟 컨트롤은 커서하에 있던 컨트롤이 된다.<br />
또, 타겟 윈도우·컨트롤을 소유하는 프로세스는 타겟 프로세스가 된다.<br />
「설정」으로 「액티브 윈도우를 타겟으로 한다」를 선택하는 것으로, 제스 차의 입력 개시시에 액티브했던 윈도우를 타겟 윈도우, 입력초점이 있던 컨트롤을 타겟 컨트롤로 하는 것도 가능하다.
</p>
<img src="0020.png" width="401" height="411" alt="(22011bytes)">



<p>설정 화면의 「조건 정의」페이지로, 마우스 커서하의 윈도우등의 조건에 응한 할당을 행하기 위한 조건 정의를 등록할 수 있다.<br />
초기 상태에서는, 몇개의 표준적인 조건이 등록되어 있다.<br />
「↑」 「↓」버튼에서는, 엔트리의 줄서 바꾸어가, 「-」에서는 삭제를 실시할 수 있다.<br />
새로운 정의를 추가하려면 , 우선 「+」버튼으로 신규 엔트리를 작성한다.<br />
</p>
<p>「C」버튼에서는, 조건 정의를 텍스트화한 문자열이 크리프보드에 카피된다.「크리프보드로부터 임포트」를 실행하면, 반대로 크리프보드상의 정의 문자열을 설정에 추가할 수 있다.<br />
이것에 의해, 게시판등에서 다른 유저라는 정의 정보의 수수를 원활히 실시할 수 있다.
</p>
<p>
덧붙여 특별한 조건인 「Disable」에는, 제스 차의 인식을 무효로 하고 싶은 프로그램의 조건을 등록한다.<br />
게임등에서, 제스 차가 유효하게 되어 있으면 불편이 발생하는 경우나, 프로그램이 독자적으로 탑재하고 있는 제스 차 기능을 이용하고 싶은 경우 등에 사용한다.
</p>
<br clear="all" />

<img src="0030.png" width="401" height="411" alt="(21694bytes)">
<p>신규의 조건 정의를 작성하면, 「정의명」에 알기 쉬운 명칭을 입력해 「변경」을 실행한다.</p>
<p>
덧붙여 설정이AutoHotkey의 스크립트에 변환될 때, 정의명은 함수명으로서 사용되기 위해, 반각영숫자나 「_」이외의 문자는 사용할 수 없다.
</p>
<p>
동작 할당으로 사용되고 있는 정의의 이름을 변경하려고 했을 경우는, 동작 할당측의 이름을 옮겨놓을지를 문의하는 다이얼로그가 표시된다.<br />
동작 할당측의 이름을 옮겨놓지 않았던 경우는, 수동으로 동작 할당을 변경·해제하는지, 새롭게 변경전의 이름으로 조건을 작성할 필요가 있다.
</p>
<br clear="all" />

<div style="float:right">
<img src="0040.png" width="401" height="411" alt="(21107bytes)" style="display:block;float:none" >
<img src="0050.png" width="414" height="558" alt="(25665bytes)" style="display:block;float:none">
</div>
<p>다음에, 조건을 판별하는 방법을 선택해, 조건치를 입력한다.<br />
조건 종별은, 각각 이하와 같은 의미가 있다
</p>
<dl>
<dt>윈도우 클래스</dt><dd>
윈도우 생성시에 프로그램에 의해서 주어지는, 종류를 식별하기 위한 이름.<br />
대체로의 경우, 소프트마다, 윈도우의 종류 마다 고유의 클래스 이름이 지어질 수 있어서라고 내려 「화상 viewer의 화상 윈도우만」 등, 충분히 상세한 조건 판별을 할 수 있는 경우가 많다.<br />
그러나, 「Form1」(와)과 같은 개발툴이 디폴트로 붙이는 이름이 되어 있는 경우 등은, 다른 소프트와 구별할 수 없기 때문에, 판별에는 사용할 수 없다.<br />
또, 보기 드물게 클래스명이 랜덤인 문자열이 되어 있는 경우도 있다.
</dd>
<dt>컨트롤 클래스</dt><dd>
윈도우상의 컨트롤의 생성시에 붙여진 종류를 식별하기 위한 이름.<br />
표준적인 컨트롤이면, 대체로의 어플리케이션으로 같은 클래스명이 되어 있다.<br />
윈도우 클래스에서는 판별할 수 없지만, 컨트롤 클래스에서는 충분히 판별할 수 있는 경우나, 윈도우상의 특정의 부분에서만 동작 할당을 실시하고 싶은 경우 등에 사용한다.
</dd>
<dt>실행 파일명</dt><dd>
타겟 프로세스의 실행 파일명(폴더 패스를 제외한 이름 부분).<br />
윈도우/컨트롤 클래스가 부정이거나 다른 프로그램과 같기도 하고 해 식별로 사용할 수 없는 경우에 사용한다.
</dd>
<dt>타이틀</dt><dd>
윈도우의 타이틀.통상은, 타이틀 바에 표시되고 있는 문자열.<br />
스크립트 호스트등에서 실행되는 프로그램 등, 클래스에서도 실행 파일명에서도 판별할 수 없는 케이스로 사용한다.<br />
덧붙여 판별은 완전 일치로 행해진다.<br />
부분 일치로 판별하고 싶은 경우는, 커스텀 조건식에서 「InStr(MG_Title,"검색 문자열")」(이)나 「RegExMatch(MG_Title,"검색 패턴")」(와)과 같은 조건을 지정하면 된다.
</dd>
<dt>커스텀 조건식</dt><dd>
AutoHotkey의 「<a target=_top href='../../commands/IfExpression.html'>if()</a>」등에서 사용한다<a target=_top href='../../Expression.html'>식</a>(을)를 지정한다.<br />
「입력 보조」를 크리크 하면, 윈도우의 부위등의 pre-set가 메뉴 표시된다.<br />
그 외의 고도의 사용법에 대해서는,<a target=_top href='../../myscripts/mousegesture/index.html#target'>고도의 조건 정의</a>(이)나,readme.txt안의 변수 일람등을 참조.
</dd>
<dt>타정의와의 일치</dt><dd>
값으로 지정한 정의명의 조건에 일치할지<br />
「 어떤 것인가에 일치」와「모두에 일치」를 조합해 사용하고 싶은 경우에 사용한다.
</dd>
</dl>

<p>「입력 보조」를 누르고, 조건으로서 등록하고 싶은 윈도우를 오른쪽 크리크 하면, 조건치가 취득되어 「값」의 란에 입력된다.<br />
「커스텀 조건식」, 「타정의와의 일치」에서는, pop-up menu가 표시되어 크리크 한 항목이 조건치로서 입력된다.
</p>
<br clear="all" />

<img src="0060.png" width="401" height="411" alt="(18035bytes)">
<p>
「추가」버튼을 누르는 것으로, 오른쪽의 리스트에 조건이 추가된다.<br />
조건은 복수 등록할 수 있다.<br />
리스트의 오른쪽의 「×」버튼으로 조건의 삭제, 「↑」 「↓」버튼으로 나란해져 바꾸어가 실시할 수 있다.<br />
여기서의 줄 순서 대로에 판별 처리를 하지만, 기본적으로 판별 결과에는 영향을 주지 않는다.
</p>
<p>
리스트의 오른쪽 아래의 드롭 다운 리스트에서는, 복수의 조건이 등록되었을 경우의 취급을 「 어떤 것인가에 일치」와「모두에 일치」로부터 선택할 수 있다.<br />
「 어떤 것인가에 일치」는, 「IE(와)과Firefox(와)과Opera」 등 복수가 다른 프로그램에 정리해 같은 동작을 할당하고 싶은 경우 등에 사용한다.<br />
「모두에 일치」는, 「Hoge.exe의Form1클래스의 윈도우」나 「익스플로러의 트리 부분」 등, 복수의 조건으로 좁혀 대경우에 사용한다.
</p>
<br clear="all" />







<a name="gesture"></a><h3>제스 차 정의</h3>
<p>
MouseGesture.ahk그럼, 제스 차는 「특정의 버튼의 눌러 내려」 「밀리고 있는 버튼을 어떤 것이나 하나 놓는다」 「휠 회전등의 조작」 「커서를 특정의 방향에 일정 이상 이동(스트로크)」등의 조작의 연속으로서 정의된다.<br />
예를 들면, 일반적인 제스 차 툴로의 「 오른쪽 버튼을 누르면서 왼쪽 크리크」는 「 오른쪽 버튼을 눌러 내려 왼쪽 버튼을 눌러 내려 버튼을 어떤 것이나 하나(이 경우는 왼쪽 버튼)놓는다」, 「 오른쪽 버튼을 누르면서 커서를 왼쪽으로 이동」은, 「 오른쪽 버튼을 눌러 내려 커서를 왼쪽으로 이동해, 버튼을 어떤 것이나 하나(이 경우는 오른쪽 버튼)놓는다」라고 하는 조작으로서 나타내진다.
</p>
<img src="0080.png" width="401" height="411" alt="(19049bytes)">
<p>
새로운 제스 차를 정의하려면 , 「제스 차 정의」탭으로 「+」버튼을 눌러 신규 작성해, 적당한 명칭을 입력해 「변경」을 누른다.<br />
제스 차 정의의 정의명에는, 일본어도 사용할 수 있다.
</p>
<p>
다음에, 오른쪽 아래의 팔레트로 제스 차의 패턴을 입력해 나간다.<br />
입력중의 패턴은, 중앙의 편집란에 표시된다.편집란을 직접 편집해 지정하는 일도 가능.<br />
오른쪽의 리스트를 더블 클릭 하면, 패턴의 말미에 버튼 조작이 추가된다.<br />
하나 이상의 버튼 눌러 인하가 입력된 상태에서는, 「커서 이동」의 버튼을 누르는 일로, 커서 이동을 추가할 수 있다.
</p>
<p>
버튼의 크리크등을 나타내려면 , 마지막에 「버튼을 어떤 것이나 하나 놓는다」를 붙일 필요가 있다.<br />
덧붙여 놓는 버튼의 차례를 구별하는 일은 할 수 없다.「 오른쪽 버튼을 누르면서 왼쪽 버튼을 눌러 놓는다」라고, 「 오른쪽 버튼을 누르면서 왼쪽 버튼을 눌러 오른쪽 버튼을 먼저 놓는다」는 같은 제스 차로 간주해진다.<br />
고도의 기능에 대해서는, 「<a target=_top href='../../myscripts/mousegesture/index.html#gesture'>고도의 제스 차 정의</a>」(을)를 참조.
</p>
<br clear="all" />

<img src="0110.png" width="401" height="411" alt="(25966bytes)">
<p>
「추가」버튼을 누르는 것으로, 정의가 추가된다.<br />
하나의 정의에 복수의 제스 차를 등록하는 일도 가능.<br />
「←↑→↓」 「↑→↓←」과 같이 닮은 제스 차를 하나의 정의에 정리하고, 어떤 것이 입력되어도 의도한 동작이 실행되도록 할 수 있다.<br />
「×」버튼으로 삭제를 실시할 수 있는 것 외에 「↑」 「↓」으로 나란해져 바꾸어도 가능하지만, 줄 순서로 동작에 차이가 나타나는 일은 없다.
</p>
<br clear="all" />



<a name="action"></a><h3>동작 할당</h3>
<img src="0120.png" width="401" height="411" alt="(25793bytes)">
<p>
「동작 할당해」의 탭에서는, 제스 차 정의로 작성한 제스 차에 대해서 동작의 할당을 등록한다.<br />
왼쪽의 리스트로 제스 차를 선택하면, 「조건」으로 조건을 선택한다.<br />
특별한 조건 「Default」에는, 다른 어느 조건에도 일치하지 않았던 경우에 실행되는 동작을 지정한다.<br />
어느 조건에도 일치하지 않고,Default에도 동작을 할당할 수 있지 않은 경우는, 어떤 동작도 행해지지 않는다.<br />
Default이외의 복수의 조건에 일치하는 경우는, 리스트로 제일 위가 되어 있는 조건에 할당할 수 있었던 동작만이 실행된다.
</p>
<br clear="all" />

<img src="0130.png" width="401" height="552" alt="(28750bytes)">
<p>
하부가 큰 입력란에, 실행되는 동작을AutoHotkey의 스크립트로 기술한다.<br />
덧붙여 드롭 다운 리스트로부터 템플릿을 선택해, 「입력 보조」를 누르면, 스크립트가 자동 입력된다.<br />
대표적인 템플릿에는, 이하와 같은 것이 있다.
</p>
<dl>
<dt>키 조작을 발생시킨다</dt><dd>
파라미터로 지정된 키스트로크(keystroke)를 발생시킨다.<br />
문자 키는 단지 「a」 등, 그 이외의 키는 「{F1}」(와)과 같이 보통 괄호로 둘러싸 나타낸다.<br />
Shift/Ctrl/Alt/Win키와의 편성은, 각각 「+」 「^」 「!」 「#」(을)를 앞에 두고 붙여 나타낸다.<br />
자세한 것은<a target=_top href='../../commands/Send.html'>Send</a>커멘드의 설명을 참조.
</dd>
<dt>툴바 버튼의 커멘드를 실행</dt><dd>
실행시키고 싶은 툴바의 버튼을 오른쪽 크리크 하면, 그 버튼의 커멘드를 실행시키기 위한 스크립트가 생성된다.
</dd>
<dt>도구모음의 커멘드를 실행</dt><dd>
표준적인 도구모음의 커멘드를 실행한다.<br />
도구모음 항목명, 부메뉴명(있으면), 메뉴 항목명의 텍스트를 「,」(으)로 단락지어 지정한다.<br />
이 방법으로 조작할 수 없는 메뉴도, 「(<u>F</u>)」(와)과 같은 가속기-키에 대응한 「Alt+F」(와)과 같은 키 조작을 송신하는 것으로 실행 당하는 경우가 있다.
</dd>
<dt>프로그램을 기동</dt><dd>
커멘드 라인을 지정해 프로그램을 실행한다.비상주형의 1대의 비행기능유틸리티등을 호출해 이용한다.
</dd>
</dl>


<br clear="all" />

<img src="0140.png" width="376" height="200" alt="(11275bytes)">
<p>
「키 조작을 발생시킨다」등의 입력 보조에서는, 동작의 상세를 지정하는 파라미터를 입력하는 다이얼로그가 표시된다.
</p>
<br clear="all" />

<img src="0150.png" width="401" height="411" alt="(23129bytes)">
<p>
입력 보조의 처리가 완료하면, 이와 같이 스크립트가 입력된다.<br />
「추가」버튼을 누르는 것으로, 동작 할당이 추가된다.<br />
「×」으로 할당의 삭제, 「↑」 「↓」으로 우선 순위의 줄서 바꾸어를 실시할 수 있다.
</p>

<p>
오른쪽 아래의 「OK」버튼을 누르면, 설정이 「MG_Config.ahk」라고 하는 스크립트 파일에 변환되어 스크립트가 재기동해, 설정이 유효하게 된다.
</p>
<br clear="all" />



<a name="config"></a><h3>그 외의 설정</h3>
<img src="0170.png" width="401" height="411" alt="(31131bytes)">
<p></p>


<dl>
<dt>스트로크 인식에 필요한 피크셀수</dt>
<dd>
제스 차 인식중에 이 거리 이상 커서가 이동하면 스트로크로서 인식된다.<br />
통상 스트로크 이외의 항목은, 장거리 스트로크로 간주해지는 이동거리의 설정.
장거리 스트로크에 대해서는<a target=_top href='../../myscripts/mousegesture/index.html#gesture'>고도의 제스 차 정의</a>(을)를 참조.
</dd>
<dt>타임 아웃</dt>
<dd>
「이동 개시로 간주해지지 않은 피크셀수」이상 커서가 움직인 다음에, 「정지로 간주하는 시간」이상 커서를 정지시키면, 제스 차의 인식이 중지되게 된다.
</dd>

<dt>더블 제스 차의 간격 상한</dt>
<dd>
제스 차중에 모든 버튼이 놓아지고 나서 추가의 제스 차의 입력을 받아들이는 시간을 밀리 세컨드로 지정한다.<br />
</dd>

<dt>스트로크 인식의 인터벌</dt>
<dd>
제스 차 인식중에 커서의 위치의 체크를 실시하는 간격.<br />
크게 한다고 인식 처리의 부하가 줄어 들지만, 인식 정도는 저하한다.
</dd>

<dt>액티브 윈도우를 타겟으로 한다</dt>
<dd>
제스 차 개시시의 커서하의 윈도우·컨트롤이 아니고,
액티브 윈도우와 쌀국수 앙금이 있던 컨트롤을 타겟으로 간주한다.
</dd>

<dt>기동시부터 네비를 유효</dt>
<dd>
입력중의 제스 차 문자열을 툴 팁 표시하는 기능을 기동시부터ON(으)로 한다.
</dd>

<dt>화살표 네비</dt>
<dd>
제스 차 문자열대신에, 입력된 스트로크를 화살표로 표시한다<br />
화살표 이외의 문자나 커스텀 툴 팁은 표시되지 않는다.
</dd>

<dt>트레이 메뉴를 부메뉴화</dt>
<dd>
task tray 아이콘의 오른쪽 크리크메뉴로,MouseGesture.ahk의 커멘드를 부메뉴화해,AutoHotkey의 표준 커멘드를 루트에 표시한다.
</dd>


<dt>팔방향모드</dt>
<dd>
스트로크를 상하 좌우의4방향이 아니고, 기울기를 포함한다8방향으로 인식한다<br />
8방향 모드가 유효하게 되어 있는 경우, 스트로크를 나타내는 문자는 「LDRU」(은)는 아니고 「41236987」(이)가 된다.<br />
이 때문에, 다른 모드로 등록한 제스 차는 인식되지 않는다.<br />
8방향 모드로 이행할지도 모르는 경우는,8방향 모드를 선택해 「기울기의 넓이」를0(으)로 설정해 두면 좋다.<br />
8방향 모드용의 제스 차와4방향 모드용의 제스 차를 혼재해 등록시키는 일은 가능.
</dd>

<dt>기울기의 넓이</dt>
<dd>
진기울기(45,135,225,315도)(을)를 중심으로 몇 번의 범위를 기울기로 간주하는지를 설정한다.<br />
0(으)로 하면 종횡에만,90(으)로 하면 기울기만,45번으로 종횡도45번의8등분이 된다.<br />
기울기를 인식하기 쉽게 하고 싶은 경우는60, 인식 되기 어렵게 하고 싶은 경우는30(으)로 하면 좋다.<br />
제1스트로크만 기울기를 사용하는 경우, 「종횡의 뒤」 「기울기의 뒤」를0(으)로 한다.<br />
종횡으로 개시했을 때는 종횡만, 비스듬하고 개시했을 때는 기울기에만 하는 경우는, 「종횡의 뒤」를0에, 「기울기의 뒤」를90(으)로 한다.
</dd>


<dt>신규 버튼 정의</dt>
<dd>
「키」로AutoHotkey의 키명을, 「이름」에 제스 차 정의로 사용하는 버튼명을 지정해 「작성」을 누르면, 그 키가 밀렸을 때에 버튼으로서 인식되게 된다.<br />
마우스의 제6버튼 이후 등을 버튼으로서 사용하고 싶을 때에 이용한다.<br />
미리 드라이버 유틸리티의 설정등에서 버튼이 어떠한 키로서 동작하도록(듯이) 설정해 둔다.사용하는 키는, 통상 사용되지 않는다F13~F24키등이 바람직하다<br />
예를 들면, 다버튼 마우스의 드라이버 유틸리티로 제6버튼에F13키를 할당해 「이름」에X3B, 「키」에 「F13」라고 입력해 「실행」을 누르면, 제6버튼이 「X3B」로서 「제스 차 정의」탭의 버튼 일람에 추가된다.<br />
좌우 틸트나 제6~12버튼을 제스 차 정의란의 버튼명 일람에 올바르게 표시시키고 싶은 경우는, 버튼명을 각각 「LT」 「RT」 「X3B」~ 「X9B」로서 정의하는 것.
</dd>
</dl>


<br clear="all" />






<!-- 
<img src="0160.png" width="689" height="602" alt="(66047bytes)">
<p></p>
<br clear="all" />

<img src="0180.png" width="401" height="411" alt="(27969bytes)">
<p>에는,
이후, 「제스 차 정의」의 버튼 일람에 추가되어 제스 차로 사용할 수 있게 된다.<br />
일반적인 추가 버튼용의 이름으로서 제6버튼~ 제12버튼을 나타내는 「X3B」~ 「X9B」, 좌우 틸트를 나타내는 「LT」 「RT」(이)가 준비되어 있다.<br />
이러한 버튼은, 이러한 이름으로 등록하는 일로, 버튼 일람에 알기 쉬운 이름으로 표시된다.<br />
그 이외의 버튼명은, 단지 버튼명이 표시된다.
</p>
<br clear="all" />
<img src="0190.png" width="180" height="107" alt="(1252bytes)">
<img src="0200.png" width="179" height="130" alt="(1166bytes)">
<p></p>
<br clear="all" />


 -->

<a name="screenedge"></a><h3>화면단 접촉 인식</h3>
<div style="float:right">
<img src="0280.png" width="465" height="281" alt="(27788bytes)" style="display:block;float:none">
<img src="0290.png" width="401" height="411" alt="(20162bytes)" style="display:block;float:none">
</div>
<p>MouseGesture.ahk에는, 옵션으로서 데스크탑의 외주에 커서가 접한 것을 검출해 동작을 실행시키는 기능도 준비되어 있다.<br />
외주에 접촉하는 것이 버튼의 눌러 내려 떨어지는 것이 밀어 올려로서 다루어진다.<br />
통상의 버튼 조작이나 스트로크와 조합한 제스 차도 정의 가능.<br />
「MG_ScreenEdge」폴더내의 「buttons」폴더에 격납되고 있는 버튼 정의 파일을, 「MG_Buttons」폴더로 이동하는 것으로, 제스 차 정의로 사용할 수 있게 된다.<br />
버튼 정의는, 네 귀퉁이와 각변, 각변2등분,3등분의 합계28종류가 준비되어 있다.<br />
모두를MG_Buttons에 넣으면, 제스 차 정의의 버튼 일람이 너무 증가해서 방해이므로, 필요한 것만을 넣는다.
</p>
<p>
각변의 「전체」와「반」이나 「1/3」 등 중복 하는 부분이 동시에 유효화 되고 있는 경우, 「1/3」 「반」 「전체」의 순서로 우선적으로 인식된다.<br />
예를 들면, 상단계 중 「상단 전체」와「상단왼쪽1/3」만이 유효하게 되어 있는 경우, 상단의 왼쪽1/3(은)는 「상단왼쪽1/3」, 나머지2/3(은)는 「상단 전체」로서 인식된다.<br />
모퉁이는 옆보다 우선되지만, 「우상각」이라고 모두 「상단 전체」 「오른쪽 끝 전체」등이 유효화 되고 있는 경우, 뿔에 닿는 것보다 먼저 옆에 접촉해 인식되어 버리는 것이 많아, 모퉁이에의 접촉을 인식시키는 것이 어려워져 버린다.<br />
모퉁이에의 접촉을 사용하고 싶은 경우, 모퉁이와 연결되고 있는 옆은 사용하지 않게 하면 된다.
</p>
<br clear="all" />
<p>
각각의 버튼명이라고 인식 개소의 대응은 이하와 같다.
</p>
<table style="background-color:#CCCCCC">
<tr>
<td>
<dl compact="compact">
<dt>CRT</dt><dd>우상각</dd>
<dt>CLT</dt><dd>좌상각</dd>
<dt>CRB</dt><dd>오른쪽 아래 모퉁이</dd>
<dt>CLB</dt><dd>왼쪽 아래 모퉁이</dd>
</dl>
</td>
<td>
<dl compact="compact">
<dt>ET</dt><dd>상단 전체</dd>
<dt>ETA</dt><dd>상단왼쪽 반</dd>
<dt>ETB</dt><dd>상단 오른쪽 반</dd>
<dt>ET1</dt><dd>상단왼쪽1/3</dd>
<dt>ET2</dt><dd>상단 중앙1/3</dd>
<dt>ET3</dt><dd>상단 오른쪽1/3</dd>
</dl>
</td>
<td>
<dl compact="compact">
<dt>EB</dt><dd>하단 전체</dd>
<dt>EBA</dt><dd>하단왼쪽 반</dd>
<dt>EBB</dt><dd>하단 오른쪽 반</dd>
<dt>EB1</dt><dd>하단왼쪽1/3</dd>
<dt>EB2</dt><dd>하단 중앙1/3</dd>
<dt>EB3</dt><dd>하단 오른쪽1/3</dd>
</dl>
</td>
<td>
<dl compact="compact">
<dt>EL</dt><dd>좌단 전체</dd>
<dt>ELA</dt><dd>좌단 상반분</dd>
<dt>ELB</dt><dd>좌단 하반신</dd>
<dt>EL1</dt><dd>좌단상1/3</dd>
<dt>EL2</dt><dd>좌단 중앙1/3</dd>
<dt>EL3</dt><dd>좌단하1/3</dd>
</dl>
</td>
<td>
<dl compact="compact">
<dt>ER</dt><dd>오른쪽 끝 전체</dd>
<dt>ERA</dt><dd>오른쪽 끝 상반분</dd>
<dt>ERB</dt><dd>오른쪽 끝 하반신</dd>
<dt>ER1</dt><dd>오른쪽 끝 위1/3</dd>
<dt>ER2</dt><dd>오른쪽 끝 중앙1/3</dd>
<dt>ER3</dt><dd>오른쪽 끝 아래1/3</dd>
</dl>
</td>

</tr>
</table>




<a name="import"></a><h3>설정의 임포트</h3>
<img src="0240.png" width="401" height="411" alt="(17994bytes)">
<p>
아래와 같은INI파일 형식의 텍스트는, 크리프보드에 카피한 상태로 「크리프보드로부터 임포트」버튼을 누르는 것으로, 간단하게 설정에 추가할 수 있다.<br />
동고의Readme.txt안에, 몇개의 이용예가 게재되고 있다.
</p>
<pre class=".ini">
[우↑]
G=RB_U_
[우↓]
G=RB_D_
[우←]
G=RB_L_
[우→]
G=RB_R_
[우+←→]
G=RB_LR_
[우+왼쪽 크리크]
G=RB_LB__
[우+중앙 크리크]
G=RB_MB__
[오른쪽 휠↑]
G=RB_WU_
[오른쪽 휠↓]
G=RB_WD_
</pre>

<br clear="all" />

<a name="ini"></a><h3>MouseGesture.ini의 직접 편집에 의한 설정</h3>
<p>
ini파일의 사양은, 텍스트 문자 편집기등에서도 편집하기 쉽게, 직감적인 최소한의 기술로 동작을 정의할 수 있도록 설계되고 있다.<br />
키보드만으로 이동이나 기술을 행 네, 검색, 치환, 카피&amp;페이스트등의 기능을 이용할 수 있기 위해, 익숙해지면 편집 화면을 사용하는 것보다 효율적으로 설정을 실시할 수 있다.
</p>

<p>
트레이 메뉴의 「설정 편집」으로, 전술의 설정 화면 대신에 텍스트 문자 편집기를 기동하도록(듯이) 하려면 ,MouseGesture.ini의 「[Settings]」섹션 이하에, 이하와 같은 기술을 추가하면 된다.아래와 같이 예의 경우,ini파일에 표준으로 관련 지을 수 있었던 에디터로 열린다.<br />
ini파일을 직접 편집했을 경우는, 트레이 메뉴로부터 「재기동」을 실행하는지, hot key등에서 「GoSub,MG_Reload」(을)를 실행하는 것으로써, 수동으로 설정을 반영시킬 필요가 있다.
</p>

<pre>
EditCommand="edit " . A_ScriptDir . "\MouseGesture.ini"
</pre>


<p>
조건 정의 섹션에서는, 조건 정의 화면의 정의명에 상당하는 것을 섹션명으로 한다.<br />
엔트리명은, 조건 일람의 「조건 종별」로 표시되는 것(「WClass」 「CClass」 「Title」 「Exe」 「Custom」 「Include」), 그리고, 엔트리의 값은 「조건치」에 표시되는 것을 기술한다.같은 이름의 엔트리는, 몇에서도 기술해 상관없다.<br />
또, 「모두에 일치」를 지정하려면 , 「And=1」라고 하는 엔트리를 기술한다.<br />
예를 들면, 익스플로러의 트리를 「ExplorerTree」라고 하는 조건명으로 등록하려면 , 아래와 같이 기술한다.
</p>
<pre>
[ExplorerTree]
WClass=ExploreWClass
CClass=SysTreeView32
And=1
</pre>


<p>
제스 차 정의와 동작 할당은, 같은 섹션에 기술한다.섹션명은, 뭐든지 좋다.<br />
「G」라고 하는 이름의 엔트리로, 제스 차 문자열을 정의한다.이 엔트리는, 몇에서도 기술해 상관없다.<br />
동작 할당은, 할당하고 싶은 조건 정의명이나 「Default」(을)를 엔트리명으로서 할당하는 스크립트를 값으로 해서 기술한다.<br />
스크립트를 복수행으로 할 필요가 있는 경우는, 개행 대신에Tab문자를 사용해,1행으로 기술한다.<br />
몇행에 달하는 복잡한 스크립트를 할당하고 싶은 경우는,MG_User.ahk에 써브루틴이나 함수로서 기술하고, 그것을 호출하는 처리를 동작 할당해에 기술하는 것이 좋다.
MG_User.ahk의 부분을 변경했을 경우도, 메뉴의 「재기동」이나 「MG_Reload」써브루틴으로 재독 봐 필요가 있다.
</p>

<p>
「Settings」섹션에는, 「설정」화면에서 설정하는 정보를 기술한다.<br />
체크 박스는,OFF하0,ON하1(와)과 기술한다.
</p>



<a name="target2"></a><h2>고도의 조건 정의</h2>

<p>
조건 정의의 「커스텀 조건식」에서는, 조건치로서AutoHotkey의 조건식을 기술하는 것으로, 님 들인 조건에 의한 타겟 판별을 실시할 수 있다.<br />
MouseGesture.ahk에 준비되어 있는 변수나 함수를 이용하면, 통상에서는 다른 윈도우와 구별 하기 어려운 윈도우에서도 프로그램별의 동작 할당이 실현 가능.<br />
또, 컨트롤이나 윈도우의 부위에 따르고, 세세하게 조건을 나눌 수도 있다.<br />
덧붙여 값의 비교시는, 이식성을 높이기 위해 「=」 「<>」연산자는 아니고 「==」 「!=」연산자를 사용하도록(듯이) 하는 것.
</p>

<a name="title"></a><h3>타이틀의 부분 일치에 의한 윈도우의 판별</h3>
<p>
AutoHotkey의 스크립트나Java제의 프로그램 등은, 어느 프로그램에서도 「실행 파일명」이 「AutoHotkey.exe」(이)나 「javaw.exe」(이)가 되어 버려, 어느 프로그램의 윈도우인가를 판별할 수 없다.<br />
또, 윈도우 클래스나 컨트롤 클래스도, 「AutoHotkeyGUI」(이)나 「SunAwtFrame」(와)과 같은 일정한 이름이 되어 있고, 판별로 사용할 수 없는 것이 많다.<br />
이러한 경우는, 타이틀 바에 표시되는 윈도우 타이틀로 판별하면 좋다.
</p>
<p>
그러나, 윈도우 타이틀은, 열려 있는 파일명등이 표시되고, 일정은 아니게 되고 있는 경우가 있다.<br />
이 경우에서도, 「C:\Program Files\AutoHotkey\AutoHotkey.ini<em> SomeEditor</em>」(와)과 같이, 타이틀에 부가되는 프로그램명등을 표적으로 하면 판별할 수 있다.<br />
타이틀의 부분 일치로 판정하려면 , 조건 종별의 「커스텀 조건식」에서, 「InStr(MG_Title,"검색하는 문자열")」(와)과 같이 하면 된다.<br />
</p>
<p>다만, 단지 「InStr(MG_Title," SomeEditor")」의 조건만으로 판별하면, 「 SomeEditor」(을)를 포함한 타이틀이 되어 있는 다른 소프트에도 일치해 버린다.<br />
이것을 막으려면 , 윈도우 클래스나 프로그램명등의 조건과 조합하고, 「모두에 일치」를 선택하고, 조건을 좁히면 된다.
</p>
<p>
또, 정규 표현을 이용하면, 타이틀의 선두나 말미에 포함되는 경우에게만 일치로 간주하는 등의 고도의 조건 정의도 가능하다.<br />
선두에게만 일치시키려면 , 「RegExMatch(MG_Title,"^검색하는 문자열")」, 말미에게만 일치시키려면  「RegExMatch(MG_Title,"검색하는 문자열$")」라고 한다.
</p>




<a name="commandline"></a><h3>커멘드 라인 문자열에 의한 프로그램의 판별</h3>
<p>
타이틀에도 표적이 되는 문자열이 없는 경우에서도, 프로그램 실행시의 커멘드 라인으로 판별할 수 있는 경우가 있다.<br />
예를 들면,AutoHotkey의 스크립트를 실행하고 있는 프로세스는, 「"(폴더 패스)\AutoHtkey.exe" "(스크립트 파일의 패스).ahk"」(와)과 같은 커멘드 라인으로 기동된다.<br />
타겟 프로세스의 기동에 사용된 커멘드 라인은, 「MG_CommandLine()」함수로 취득할 수 있다.<br />
커스텀 조건식에서, 「InStr(MG_CommandLine(),"MG_Edit.ahk")」(와)과 같이 해 사용하면 된다.<br />
이 조건만이라고, 스크립트 파일을 편집하고 있는 에디터 등도 일치로 간주해져 버리므로, 실행 파일명으로 조합해 「모두에 일치」로 판별하는지, 정규 표현을 이용해 「RegExMatch(MG_CommandLine(),"\\AutoHotkey\.exe.*MG_Edit\.ahk")」(와)과 같이 실행 파일명 부분과 스크립트 파일명 부분의 양쪽 모두를 체크하도록(듯이) 하면 좋다.

</p>
<a name="file"></a><h3>타이틀에 의한 열려 있는 파일·페이지의 판별</h3>
<p>
타이틀이나 커멘드 라인에 의한 판별을 응용하면, 「Google(을)를 표시하고 있을 때 마셔 유효」나 「HTML파일의 편집중만 유효」라고 하는 할당도 실현될 수 있다.
</p>


<img src="0270.png" width="401" height="411" alt="(18178bytes)">
<a name="hittest"></a><h3>윈도우의 부위의 판별</h3>
<p>타이틀 바나 테두리 등, 윈도우의 부위를 판별하는 함수로서 「MG_HitTest()」 「MG_TreeListHitTest()」등의 함수가 준비되어 있다.<br />
이러한 함수를 이용한 조건식은, 「입력 보조」로 표시되는 템플릿 메뉴의 「윈도우의 부위」로부터 입력할 수 있다.<br />
이것에 의해, 「타이틀 바를 호이르크리크로 최소화」등의 동작 할당을 실현될 수 있다.
</p>

<a name="cursor"></a><h3>마우스 커서에 의한 부위의 판별</h3>
<p>
마우스 커서의 핸들을 취득하는 「MG_GetCursor()」(을)를 사용하는 것으로, 브라우저의 링크 등, 컨트롤상의 부위를 판별할 수 있는 경우가 있다.<br />
입력 보조 메뉴에는,Windows그리고 표준 정의되고 있는 커서 종별이나, 표준 커서일지의 판별을 실시하는 조건식이 준비되어 있다.
</p>

<p>
Windows의 표준 커서가 아닌 소프트 고유의 커서는, 핸들이 일정은 아니기 때문에 판별은 어렵다.<br />
그러나, 컨트롤상의 대부분에서는 표준의 커서(화살표 등)그리고, 특정의 부분에서만 비표준의 커서가 된다라고 하는 경우라면, 템플릿의 「불명(소프트 고유 등)」(으)로 판별할 수 있다.
</p>

<p>
덧붙여 커서의 취득과 판별은, 제스 차의 개시시가 아니고, 제스 차가 인식된 시점에서 행해진다.<br />
그 때문에, 스트로크를 포함한 제스 차에서는 올바르게 판별할 수 없는 것이 있다.<br />
커서에 의한 판별은, 버튼만으로 구성되는 제스 차로 사용해야 하는 것이다.
</p>





<br clear="all" />


<a name="controlrect"></a><h3>같은 클래스의 컨트롤의 좌표에 의한 구별</h3>
<p>
하나의 윈도우에 같은 클래스명의 컨트롤이 복수 있어, 각각의 컨트롤로 다른 동작 할당을 실시하고 싶은 경우는, 컨트롤의 옆·종좌표, 폭, 높이를 얻는 「MG_ControlX()」 「MG_ControlY()」 「MG_ControlW()」 「MG_ControlH()」(을)를 이용하면 좋다.<br />
예를 들면, 좌우가 되지 않아다2개의 입력란의 좌측을 판별하려면 , 「MG_ControlX()<50」(와)과 같이 한다.
</p>



<a name="windowrect"></a><h3>윈도우상의 커서 위치에 의한 판별</h3>
<p>
Sun의Java실행 환경에서 실행되고 있는 프로그램과 같이, 컨트롤을 모두 독자적으로 묘화 하고 있고,Windows의 윈도우 관리에서는 하나의 윈도우로서 밖에 인식되지 않는 듯한 경우도, 커서가 윈도우상의 어느 위치에 있을까를 조사하는 것이다 정도의 판별을 실시할 수 있다.<br />
타겟 윈도우의 옆·종좌표, 폭, 높이는, 각각 「MG_WinX()」 「MG_WinY()」 「MG_WinW()」 「MG_WinH()」(으)로 얻을 수 있다.<br />
또, 마우스 커서의 좌표는 「MG_X」 「MG_Y」변수에 격납되고 있다.<br />
따라서, 타겟 윈도우상에서의 커서 좌표를 나타내는 식은 「MG_X-MG_WinX()」가 된다.<br />
예를 들면, 윈도우의 왼쪽에서200피크셀까지의 영역을 판별하려면 , 「MG_X-MG_WinX()<200」라고 하는 식을 지정하면 된다.
</p>



<a name="pos"></a><h3>화면상의 좌표에 의한 판별</h3>
<p>
제스 차의 인식이 개시된 시점으로의 마우스 커서 좌표를 격납하고 있다MG_X,MG_Y변수를 사용하는 것으로, 제스 차 개시 위치에 응한 동작 할당도 가능.<br />
예를 들면, 가상 데스크탑 소프트와 조합하고, 화면의 오른쪽 반에서는 다음의 데스크탑으로 전환해 왼쪽 반에서는 전의 데스크탑으로 전환해라고 하는 동작을 실현할 수 있다.
</p>















<a name="gesture2"></a><h2>고도의 제스 차 정의</h2>
<p>MouseGesture.ahk그럼, 일반적인 제스 차 툴로 이용할 수 있는 「버튼을 누르면서 커서 이동」이나 「버튼을 누르면서 다른 버튼을 클릭」과 같은 제스 차 이외에도, 여러가지 제스 차를 정의 가능하다.<br />
이하에서는, 그러한 특수한 제스 차에 대해 설명한다.<br />
덧붙여 「RB_LR_」 등은, 제스 차 정의 화면등에서 표시되는 제스 차 문자열을 나타낸다.
</p>


<a name="multibuttonstroke"></a><h3>복수 버튼+스트로크</h3>
<p>
「 오른쪽 버튼, 왼쪽 버튼의 순서에 눌러 내린 상태로 커서를 이동」과 같은, 복수의 버튼을 누르면서의 스트로크에도 할당해 가능하다.<br />
예를 들면, 「RB_LB_LR_」에서는, 「 오른쪽 버튼, 왼쪽 버튼의 순서에 눌러 내린 상태로 커서를 왼쪽, 오른쪽과 이동해, 어느 쪽인가의 버튼을 놓는다」라고 하는 제스 차를 정의할 수 있다.<br />
또, 「RB_LB_LR__」에서는, 버튼이 두 개 모두 놓아진 시점에서 발동하게 된다.<br />
윈도우를 정리해 닫는 등, 오발동하면 곤란한 동작을 할당하면 좋을 것이다.
</p>




<a name="longstroke"></a><h3>장거리 스트로크</h3>
<p>커서 이동(스트로크)의 인식은, 「설정」탭의 「통상 스트로크」로 지정한 이상의 이동이면, 같은 방향으로 얼마나 이동해도 하나의 스트로크로 간주해지지만, 외3개의 설정으로 지정한 거리를 넘을 때 마다 추가로 스트로크가 인식되어 「LL」 「RR」 「UU」 「DD」(와)과 같이 인식된다.<br />
예를 들면, 「R_LL_」(은)는, 오른쪽 버튼을 누르면서 커서를 왼쪽으로 크게 이동하고 버튼을 놓았을 때에 발동한다.<br />
L그럼 최소화,LL그럼 모두 최소화와 같이, 상위판의 동작을 할당하는 등의 사용법을 하면 좋을 것이다.<br />
설정치의2배이상 이동하면, 「LLL」(와)과 같이3단계 이상의 장거리 스트로크도 인식된다.
</p>





<a name="multigesture"></a><h3>연속 발동형 제스 차</h3>

<p>
「RB_MB__」(이)나 「RB_L」(와)과 같은 제스 차에 할당할 수 있었던 동작이 발동하면, 밀리고 있는 버튼 이외의 내용이 리셋트 되어 「RB_」까지 인식된 상태로부터 인식 처리가 속행된다.<br />
그 상태로 더욱 중앙 보탄크리크를 실시하면 「RB_MB__」(이)가, 왼쪽으로 커서를 움직이면 「RB_L」(이)가 재차 인식되어 동작이 발동한다.<br />
이것에 의해, 이러한 제스 차는, 버튼을 누른 채로 몇 번이라도 연속 발동할 수 있다.
</p>

<p>
덧붙여 「RB_MB_」에 동작을 할당할 수 있고 있는 경우, 휠 버튼이 밀린 시점에서 제스 차가 발동해, 그 후 「RB_MB_」 상태로부터 인식이 속행된다.<br />
그 후 휠 버튼을 놓으면 「RB_MB__」 상태가 된다.<br />
「RB_MB__」에 동작을 할당할 수 있지 않으면, 계속해 제스 차의 입력이 가능하다.<br />
이 경우, 한번 더 중앙 버튼을 눌러도 「RB_MB__MB_」가 되고, 「RB_MB_」(은)는 발동하지 않는다.<br />
연속해 「RB_MB_」(을)를 발동 찌를 수 있던 차면, 「RB_MB__」에 하늘의 스크립트를 할당하고, 리셋트만을 발생시키도록(듯이) 하면 좋다.
</p>

<p>
입력중의 제스 차가, 등록되어 있는 어느 제스 차 문자열보다 길어지면, 입력 미스이다고 보여 자동적으로 입력 내용이 리셋트 된다.<br />
이것에 의해, 「RB_LDRU」(와)과 같은 제스 차를 연속 실행하고 있을 때 「RB_LDU」(와)과 같이 불완전한 제스 차가 입력되어 버려도, 그대로 「RB_LDULDRU……」라고 계속 입력하는 것으로「RB_」에 돌아와, 다시 「RB_LDRU」의 인식이 가능하게 된다.
</p>





<a name="longclick"></a><h3>버튼을 중인방 해 크리크 했을 때에 발동</h3>
<p>
버튼을 누르고 있던 길이에 따르고 동작을 바꾸고 싶은 경우는, 버튼을 눌러 내린 시점의 동작에, 「MG_Hold()」함수를 사용한 스크립트를 기술한다.<br />
이 함수는, 제스 차의 발동시에는, 버튼을 감시하는 타이머를 세트 해 공문자열을 돌려준다.<br />
버튼이 놓아졌을 때, 제스 차에 할당한 스크립트가 재실행된다.<br />
재실행되었을 때의 이 함수의 반치는, 버튼이 밀리고 있던 길이(밀리 세컨드)(이)가 된다.버튼 눌러 인하시의 동작으로서 이하와 같은 스크립트를 할당하는 일로, 버튼을 중인방 이바지해 놓았을 때에 동작을 실행 당한다.
</p>
<pre>
if(MG_Hold()>500){
	;중인방 해 크리크시의 동작을 기술
}
</pre>

<a name="shortclick"></a><h3>눌러 내리고 있는 시간이 짧은 크리크에 동작을 할당</h3>
<p>
MG_Hold()(을)를 이용하면, 버튼을 누르자마자 놓았을 때만 동작을 실행시키는 일도 할 수 있다.<br />
그러나, 단지 「MG_Hold()<500」라고 하면, 눌러 인하시에 실행되었을 때에도 조건이 성립해 버린다.<br />
거기서, 이하와 같이 한다.
</p>
<pre>
if(MG_Hold() && MG_Hold()<500){
	;단크리크시의 동작을 기술
}
</pre>
<p>
덧붙여 중인방 해와 단크리크에 다른 동작을 할당하려면 , 이하와 같이 하면 된다.
</p>
<pre>
if(MG_Hold()){
	if(MG_Hold()>500){
		;중인방 해 때의 동작
	}else{
		;단크리크시의 동작
	}
}
</pre>


<a name="buttonhold"></a><h3>버튼을 「눌렀을 때」와「놓았을 때」에 실행</h3>
<p>
「MB_」와「MB__」에 각각 동작을 할당하는 일에서도, 눌러 인하와 밀어 올려에 각각 동작을 할당하는 일은 가능하지만, 버튼을 누르고 있을 때 스트로크가 인식되면 「MB_L_」(와)과 같이 되어 버리고, 눌러 인하시로 밀어 올려 때의 동작을 다른 제스 차에 기술하므로 관리 하기 어려운등의 어려운 점이 있다.<br />
버튼 눌러 인하시의 동작에, 이하와 같은 스크립트를 기술하는 일로, 밀어 올려 때의 동작을 동시에 정의할 수 있다.<br />
이 경우, 눌러 내리고 있는 동안에 스트로크가 인식되어도, 밀어 올려 때의 동작은 발동한다.
</p>
<pre>
if(!MG_Hold()){
	;눌렀을 때의 동작
}else{
	;놓았을 때의 동작
}
</pre>



<a name="while"></a><h3>버튼을 누르고 있는 동안 반복 발동</h3>

<p>
「MG_While()」함수에서는, 버튼을 누르고 있는 동안 정기적으로 같은 동작이 실행된다.<br />
그 때,MG_While()의 돌아가 값은 「1」(이)가 된다.<br />
인수로서 정기 실행의 간격을 밀리 세컨드로 지정할 수 있다.미지정시는20밀리 세컨드.<br />
이하와 같이 하고, 버튼을 누르고 있는 동안 키의 연타를 발생시키거나 하는데 이용할 수 있다.
</p>
<pre>
if(MG_While(100)){
	Send,{PageDown}
}
</pre>
<p>
덧붙여 버튼을 놓은 후에도 한 번만 같은 동작이 실행된다.<br />
이 때는,MG_While()의 돌아가 값이 「0」(이)가 된다.<br />
이하와 같이 하고, 누르고 있는 동안과 놓았을 때의 동작을 정의할 수 있다.
</p>

<pre>
if(MG_While(100){
	;누르고 있는 동안의 동작
}else{
	;놓았을 때의 동작
}
</pre>

<p>
덧붙여 반복해 간격이 길면 놓았을 때의 동작의 발생이 늦는 것이 있다.<br />
놓았을 때의 동작을 이용하는 경우는, 간격은200밀리 세컨드를 넘지 않는 정도로 세워 두는 것이 좋다.
</p>


<a name="while2"></a><h3>버튼 눌러 인하시, 누르고 있는 동안, 밀어 올려 때에 발동</h3>
<p>
버튼의 감시 상태는, 「MG_WhileState」변수에 격납되고 있다.<br />
이하와 같이 하는 것으로, 「눌러 인하시」 「눌러 인하중에 반복해 실행」 「밀어 올려 때에 실행」의3대로의 동작을 실행 당한다.<br />
「눌러 인하시의 동작」의 뒤의 「MG_While(100)」(으)로 간격을 지정해 감시 등록을 실시한다.<br />
후의 「if(MG_While())」(은)는, 반복해 불려 갈 때 마셔 실행되므로, 간격을 지정할 필요는 없다.
</p>
<pre>
if(!MG_WhileState){
	;눌러 인하시의 동작
	MG_While(100)
}else if(MG_While()){
	;눌러 내리고 있는 동안의 동작
}else{
	;놓았을 때의 동작
}
</pre>


<a name="hold2"></a><h3>누르고 있는 버튼이 놓아졌을 때의 동작을 예약</h3>
<p>
MG_Hold()(은)는, 버튼 눌러 내려 이외의 순간에 발동하는 제스 차로 사용되면, 그 시점에서 눌러 내리고 있는 버튼이 놓아졌을 때에, 할당할 수 있었던 스크립트의 재호출을 실시한다.<br />
아래와 같은 스크립트를 「RB_WD_」 등에 할당해 두면, 오른쪽 버튼을 누르면서 휠을 돌렸을 때에Alt+Tab(을)를 실행해,Alt(은)는 그대로 누르고 있을 뿐으로 하고, 오른쪽 버튼이 놓아졌을 때에Alt(을)를 놓는 조작을 발생시킨다고 하는 동작을 실현할 수 있다.
</p>
<pre>
if(!MG_Hold()){
	Send,{Alt Down}{Tab}
}else{
	Send,{Alt Up}
}
</pre>




<a name="defer"></a><h3>모든 버튼이 놓아졌을 때에 발동하는 동작을 예약</h3>
<p>
제스 차에 할당하는 스크립트중에서, 「Menu,Show」(이)나 「MsgBox」(와)과 같은 스크립트의 실행이 정지되는 동작을 직접 호출하는 것은 바람직하지 않다.<br />
거기서, 「MG_Defer()」(으)로, 제스 차의 인식 처리가 종료한 후에 실행되도록(듯이) 한다.<br />
「MG_Defer()」(은)는, 등록시에는 「0」, 인식 처리의 종료후에 불려 갔을 때에는 「1」(을)를 돌려준다.<br />
「RB_LR_」(와)과 같은, 모든 버튼이 놓아진 시점에서 발동하는 제스 차도, 제스 차 인식 처리가 완전하게 종료하기 전에 실행되므로,MsgBox등을 할당할 때는 이 처치가 필요하다.
</p>
<pre>
if(MG_Defer()){
	MsgBox,% MG_Title
}
</pre>


<a name="timer"></a><h3>버튼을 일정시간 계속 눌렀을 때에 발동</h3>
<p>
버튼을 눌러 내리고 나서, 버튼을 놓지 않고 일정시간이 경과한 순간에 동작을 발동시키고 싶은 경우는, 「MG_Timer()」함수를 사용한다.<br />
이 함수가 실행되면, 타이머가 등록시 되고, 「1」(이)가 돌려주어진다.<br />
인수로 지정된 시간이 경과하면, 제스 차 내용이 변화하고 있지 않는 경우만, 같은 스크립트가 재실행된다.이 때,MG_Timer()의 돌아가 값은 「0」(이)가 된다.<br />
시간 경과전에 버튼이 놓아지거나 스트로크나 다른 버튼 조작이 인식되었을 경우는, 재실행은 행해지지 않는다.<br />
화면단 접촉 인식에의 할당으로 사용하면, 잘못해서 접했을 때에는 발동하지 않게 할 수 있다.
</p>
<p>
이하와 같은 형태로 사용한다.
</p>
<pre>
if(!MG_Timer(500)){
	;지정 시간 경과후에 실행되는 동작
}
</pre>





<a name="wait"></a><h3>크리크와 더블 클릭에 각각 동작을 할당</h3>

<p>
단지 「 오른쪽 버튼을 누르면서 왼쪽 버튼으로 더블 클릭」에 할당하고 싶으면, 「RB_LB__LB__」라고 하는 제스 차를 정의하면 된다.
</p>

<p>
그러나, 「RB_LB__」에 동작을 할당할 수 있고 있었을 경우, 그 동작이 실행된 시점에서 제스 차 내용이 「RB_」에 리셋트 되어 버리기 때문에, 「RB_LB__LB__」 상태가 되는 것이 없어져 버린다.<br />
「RB_LB__」의 동작에, 「MG_Wait()」(을)를 추가하는 것으로, 제스 차 내용의 파기를 무효화해, 추가의 입력을 접수시킬 수가 있다.
</p>

<p>
덧붙여 이와 같이 해 단독 크리크와 더블 클릭에 동작을 할당했을 경우, 더블 클릭시에는 단독 크리크의 동작과 더블 클릭의 동작이 차례로 실행되는 일이 된다.<br />
「단독 크리크로 선택, 더블 클릭으로 실행」과 같이, 더블 클릭에는, 단독 크리크의 동작으로부터 연결되는 형태의 동작을 할당하도록(듯이) 하면 좋다.
</p>
<pre>
Send,{Home}+{End}
MG_Wait()
</pre>


<a name="wait2"></a><h3>단독 더블 클릭 등, 도중에 모든 버튼이 놓아지는 제스 차</h3>
<p>
제스 차의 도중에 모든 버튼이 놓아진 상태가 되면, 스트로크의 인식 처리가 종료 함과 동시에, 입력중의 제스 차 내용은 파기된다.<br />
이 때문에, 「RB__RB__」(와)과 같은 단독의 더블 클릭 조작이나, 「RB_R_RB_D_」(와)과 같은 도중에 버튼을 놓는 복수 스트로크 제스 차는, 인식할 수 없다.<br />
그러나, 「설정」탭의 더블 제스 차의 간격 상한을 설정해 있었을 경우나, 버튼이 놓아지는 조작에 「MG_Wait(500)」(와)과 같은 동작을 할당할 수 있고 있었을 경우는, 버튼이 모두 놓아지고 나서도, 지정된 시간(밀리 세컨드)만 제스 차의 추가 입력이 가능해진다.<br />
많은 제스 차로 사용하고 싶은 경우는, 하나 하나 「MG_Wait(500)」(을)를 기술하는 것은 귀찮아서, 설정 화면에서 일괄 지정하면 좋다.
</p>






<a name="timer2"></a><h3>더블 클릭과1회만의 크리크에 다른 동작을 할당</h3>
<p>
「더블 클릭의1번째」가 아니고,1회 밖에 크리크 되지 않았을 때에게만 동작을 실행시키고 싶은 경우도, 「MG_Timer()」(을)를 이용하면 된다.<br />
MG_Timer()의 인수를 부의 값으로 하면,MG_Wait()그리고 대기 시간을 지정했을 때와 같게, 제스 차 내용 파기의 무효화와 추가 입력의 접수가 실행된다.<br />
예를 들면, 「MB__」에 이하와 같은 스크립트를 할당해 「MB__MB__」등에 다른 스크립트를 할당하면, 휠 버튼이 크리크 되어 그 후500밀리 세컨드간 다른 버튼이 인식되지 않았던 경우만, 기술된 동작이 실행된다.<br />
이 경우, 「MB__MB__」에는, 보통으로 동작을 할당하면 된다.
</p>
<pre>
if(!MG_Timer(-500)){
	;크리크가1회만이었던 경우의 동작
}
</pre>


<a name="triple"></a><h3>트리프르크리크 이상에의 할당</h3>
<p>
상기의 방법을 응용하면, 「RB_LB__LB__LB__」(와)과 같은 버튼을 누르면서의3회이상 크리크나, 「MB__MB__MB__」(와)과 같은 단독으로의3회이상 크리크도 정의 가능하다.<br />
「1회만」 「2회만」 「3회」에 각각 동작을 할당하는 경우는, 「MB__MB__」에도MG_Timer()(을)를 사용한 동작을 할당한다.
</p>



<a name="modkey"></a><h3>수식 키와의 편성</h3>
<p>
Alt등의 수식 키와 조합한 제스 차를 사용하고 싶은 경우는, 신규 버튼 정의로 수식 키를 버튼으로서 등록한다.<br />
수식 키의 본래의 기능을 유효하게 하고 싶은 경우는, 「~Alt」(와)과 같이 키명에 「~」(을)를 붙인다.<br />
Ctrl(이)나Shift(와)과 같은, 원래 마우스 조작과 조합하는 것이 많은 키를 제스 차에 사용하면, 오발동이 일어나기 쉬워지므로 추천 되지 않는다.<br />
좌우에 있는 동안의 한쪽 편 밖에 사용하지 않으면, 「RShift」 「LCtrl」(와)과 같이 하고, 좌우 어느 쪽인가의 키로 한정하면 좋다.
</p>
<p>
예를 들면,Windows키를WK버튼으로서 등록했을 경우, 「WK_RB_U_」(으)로Windows+오른쪽 버튼+상 스트로크의 제스 차를 정의할 수 있다.<br />
「WK_U」(와)과 같은, 키+스트로크의 제스 차도 정의 가능.노트PC의 터치 패드등에서 사용하면 편리할지도 모르다.<br />

</p>





<a name="action2"></a><h2>고도의 동작 할당</h2>
<p>
동작 할당에서는,AutoHotkey의 각종 커멘드·함수를 이용하는 일로, 님 들인 동작을 실현할 수 있다.<br />
이하에서는,AutoHotkey의 스크립트나MouseGesture.ahk에 준비된 함수를 이용해서 실현될 수 있는 특수한 동작에 대해 설명한다.
</p>


<a name="timeout"></a><h3>본래의 마우스 조작의 재현(타임 아웃 등)</h3>
<p>
제스 차의 인식을 해도, 할당할 수 있었던 동작이 실행되지 않았던 경우는, 극력 원래의 마우스 조작이(일순간으로)재현되게 되어 있다.<br />
예를 들면, 「R__」에 동작을 할당할 수 있지 않은 상태로 오른쪽 버튼을 눌러 놓으면, 보통으로 오른쪽 크리크를 했을 때와 같은 동작을 한다.
</p>

<p>
커서를 어느 정도 움직이고 나서, 일정시간 정지시키면, 그 시점에서 제스 차의 인식이 중지되어 지금까지의 마우스 조작이 재현된다.<br />
이것에 의해, 오른쪽 버튼이 개시 버튼에 사용되고 있는 상태에서도, 오른쪽 버튼으로의 드러그등을 이용할 수 있다.
</p>

<p>
동작에 「MG_Abort()」(을)를 할당해 발동시켰을 경우도, 제스 차의 인식은 중지된다.<br />
「RB_L」(와)과 같이, 스트로크 제스 차에 사용하지 않을 방향의 스트로크가 인식된 순간에 발동하는 제스 차에 할당하면, 즉석에서 오른쪽 드러그&amp;드롭을 개시할 수 있어 편리하다.
</p>



<p>
어느 소프트에서는 오른쪽 버튼은 제스 차에 사용하지 않고 보통으로 사용하고 싶지만, 다른 버튼의 제스 차는 사용하고 싶은 경우, 「RB_」(와)과 같은 버튼 눌러 인하 조작의 동작 할당으로, 그 소프트를 나타내는 조건에 「MG_Abort()」(을)를 할당한다.<br />
이 경우, 「Disable」조건에 일치했을 경우와 거의 같이 제스 차의 인식 처리를 하는 일 없이, 버튼 본래의 동작을 한다.
</p>



<a name="wheelredirect"></a><h3>휠로 커서하의 컨트롤을 조작</h3>
<p>
마우스 휠의 회전에서는, 통상은 액티브한 윈도우의 쌀국수 앙금이 있는 컨트롤이 조작된다.<br />
이것을 커서하의 컨트롤에 전송 하려면 , 이하와 같은 할당을 실시한다.
</p>
<pre>
[WheelRedirectUp]
G=WU_
Default=PostMessage,0x020A,% 0x00780000|GetKeyState(&quot;LButton&quot;)|GetKeyState(&quot;RButton&quot;)&lt;&lt;1|GetKeyState(&quot;Shift&quot;)&lt;&lt;2|GetKeyState(&quot;Ctrl&quot;)&lt;&lt;3|GetKeyState(&quot;MButton&quot;)&lt;&lt;4|GetKeyState(&quot;XButton1&quot;)&lt;&lt;5|GetKeyState(&quot;XButton2&quot;)&lt;&lt;6,% MG_Y&lt;&lt;16|MG_X,,ahk_id %MG_HCTL%

[WheelRedirectDown]
G=WD_
Default=PostMessage,0x020A,% 0xFF880000|GetKeyState(&quot;LButton&quot;)|GetKeyState(&quot;RButton&quot;)&lt;&lt;1|GetKeyState(&quot;Shift&quot;)&lt;&lt;2|GetKeyState(&quot;Ctrl&quot;)&lt;&lt;3|GetKeyState(&quot;MButton&quot;)&lt;&lt;4|GetKeyState(&quot;XButton1&quot;)&lt;&lt;5|GetKeyState(&quot;XButton2&quot;)&lt;&lt;6,% MG_Y&lt;&lt;16|MG_X,,ahk_id %MG_HCTL%

</pre>


<a name="movecursor"></a><h3>커서 이동의 발생</h3>
<p>
「MG_Move()」함수를 사용하면, 마우스 커서를 지정 좌표로 이동할 수 있다.<br />
인수에 옆·세로의 좌표를 지정하면 그 좌표에, 인수를 생략 하면 제스 차 개시 위치로 이동한다.
</p>
<p>
「RB_L」(와)과 같이 커서를 이동할 때 마다 반복 발생하는 제스 차는, 연속해 계속 실행하면 머지않아 화면단에 도달해 버리기 위해, 연속 실행할 수 있는 수에 한계가 있다.<br />
그러나, 동작의 뒤에 「MG_Move()」(을)를 붙이면, 동작이 실행될 때마다 커서 위치가 원래대로 돌아가기 위해, 버튼을 누른 채로 얼마든지 반복해 실행할 수 있다.

</p>




<a name="scroll"></a><h3>스크롤</h3>
<p>
MouseGesture.ahk에는, 타겟 컨트롤을 스크롤 시키는 함수가 준비되어 있다.<br />
스크롤 함수는, 「MG_Scroll()」 「MG_InstantScroll()」 「MG_DragScroll()」의3종류가 있다.<br />
모두 「MG_While()」라고 맞추고, 이하와 같이 해 사용한다
</p>
<pre>
if(MG_While()){
	MG_Scroll(-3)
}
</pre>
<p>
틸트등의 버튼을 누르고 있는 동안, 일정량씩 스크롤 시키려면 , 「LT_」등의 버튼 눌러 인하시의 동작에 상기와 같은MG_Scroll()(을)를 사용한 스크립트를 할당한다.<br />
MG_Scrooll()의 인수에는, 옆과 세로의 스크롤량을 정수로 지정한다.옆스크롤만의 경우는, 제1인수만으로 좋다.<br />
1단위 근처에서 스크롤 하는 피크셀수는, 컨트롤에 따라서 다르다.1단위로1문자/1행씩 스크롤 하는 컨트롤도 있으면,1단위로1피크세르스크로르 하는 컨트롤도 있다.<br />
상기의 예에서는, 버튼을 누르고 있는 동안, 타겟 컨트롤을 왼쪽으로 스크롤 한다.
</p>


<pre>
if(MG_While(60)){
	MG_InstantScroll(0)
}

</pre>
<p>
IE의 휠 스크롤과 같이, 버튼을 눌러 내린 위치와 현재의 커서 위치의 거리에 따라 스크롤 방향·양을 변화시키고 싶은 경우에는, 버튼의 눌러 인하 동작에 「MG_InstantScroll()」(을)를 사용한 동작을 할당한다.<br />
이 경우, 스크롤 속도를 조정하려면 , 상기와 같이MG_While()의 인수로 실행 간격을 지정한다.<br />
제1인수는, 「1」(이)라면 스크롤 시킨 만큼만 커서가 돌아온다.이 경우, 스크롤 계속 시키려면  , 커서를 계속 이동할 필요가 있다.<br />
제1인수를 「0」(으)로 했을 경우,IE의 휠 스크롤과 같은 동작이 된다.버튼을 누르고, 스크롤 시키고 싶은 방향으로 적당량 커서를 이동하면, 버튼을 계속 누르는 것만으로 스크롤 하게 된다.<br />
제2/제3인수는, 무슨 피크셀의 이동으로1단위 스크롤 시킬까의 비율(세로와 가로).<br />
</p>

<pre>
if(MG_While()){
	MG_DragScroll()
}

</pre>
<p>
MG_DragScroll()그럼, 컨트롤을 잡는 느낌으로, 마우스 커서의 움직임에 맞추어 스크롤 당한다.<br />
제1/제2인수로, 이동 피크셀수와 스크롤 단위의 비율을 지정한다.<br />
그 이외의 사용법은MG_InstantScroll()(와)과 같다.
</p>


<p>
덧붙여 이러한 스크롤 기능은, 표준의 스크롤 메세지를 무시하는 컨트롤(Gecko엔진의 브라우저 등)에는 사용할 수 없다.<br />
이러한 미대응의 컨트롤은, 조건별 할당으로 커서 키등을 송신 할 수 밖에 없다.
</p>




<a name="dropfiles"></a><h3>의사적으로 파일의 드롭을 발생시킨다</h3>

<p>
파일을 지정하는 수단이 윈도우에의 드롭만의 소프트로, 파일의 지정을 자동 실행시키고 싶을 때등을 (위해)때문에에, 「MG_DropFiles()」함수가 준비되어 있다.<br />
이 함수는, 제1인수에 드롭 하는 파일의 패스의 개행(`n)단락 리스트, 제2인수에 타이틀등의<a target=_top href='../../Window.html'>윈도우 지정 문자열</a>(을)를 지정한다.<br />
제2인수를 생략 했을 경우는, 타겟 윈도우에 드롭 된다.<br />
제1인수를 생략 했을 경우는, 크리프보드내의 파일명이 사용된다.
</p>



<a name="filestoclipboard"></a><h3>파일을 크리프보드 경유로 페이스트</h3>
<p>
파일 선택 다이얼로그로 표시되고 있는 폴더에 파일을 카피하고 싶은 경우, 파일을 크리프보드에 카피해Ctrl+V(을)를 송신해 붙인다고 하는 방법을 생각할 수 있다.<br />
이러한 경우를 위해서, 지정 파일을 크리프보드에 카피하는 「MG_FilesToClipboard()」함수가 준비되어 있다.<br />
이 함수는, 제1인수로서 파일 패스의 개행(`n)단락 리스트를 지정한다.<br />
통상은 보통 카피이지만, 제2인수에 「1」(을)를 지정하면 「절취」와 같은 상태가 되어, 붙이기를 실시했을 때에 카피는 아니고 이동을 하게 된다.

</p>




<a name="controlhiddenwindows"></a><h3>비액티브나 비표시의 윈도우를 조작</h3>
<p>
「<a target=_top href='../../commands/PostMessage.html'>PostMessage</a>」커멘드나 「<a target=_top href='../../commands/ControlSend.html'>ControlSend</a>」커멘드를 사용하는 것으로, 음악 플레이어 소프트의 조작과 같이, 커서하의 윈도우가 아니고, 실행중의 임의의 프로그램을 조작할 수도 있다.<br />
task tray에 격납 되거나 해 비표시가 되어 있는 윈도우를 조작하려면 , 사전에 「<a target=_top href='../../commands/DetectHiddenText.html'>DetectHiddenWindows</a>,On」(을)를 실행할 필요가 있다.
</p>




<a name="counter"></a><h3>실행할 때 마다2개의 동작을 교대로 반복한다</h3>
<p>
불려 간 회수를 기록하는 「MG_Counter()」(을)를 이용하는 일로, 홀수 번째의 실행시는A, 짝수 번째의 실행시는B(와)과 같이, 실행 회수에 의한 동작의 배분이 가능.<br />
인수미지정시는, 같은 제스 차의 실행 마다, 「0」 「1」(이)가 교대로 돌려주어진다.<br />
</p>
<pre>
if(MG_Counter()){
	;홀수 번째의 실행시의 동작
}else{
	;짝수 번째의 실행시의 동작
}
</pre>

<p>
MG_Counter()의 제일 인수는, 카운터의 이름을 지정한다.<br />
미지정시는, 현재의 제스 차명이 된다.<br />
조건별 실행의 타겟 마다 카운터를 독립시키고 싶은 경우나, 복수의 제스 차로 공통의 카운터를 이용하고 싶은 경우로 지정한다.
</p>

<p>
3개이상의 동작 배분을 실시하고 싶은 경우는, 제2인수로 수를 지정한다.<br />
이 경우, 「1,2,0,1,2,0」라고, 호출 회수를 제2인수로 나눈 값이 돌려주어진다.<br />
그러나, 여러 차례 불려 가면, 그때마다 카운터가 증가해 버리므로, 올바르게 동작하지 않는다.<br />
값을 다른 변수에 격납하고 나서 판정하는지,2채워 이후의 호출의 제2인수를 부로 하면 된다.<br />
제2인수가 부의 경우는, 호출 회수의 카운트는 변화하지 않고, 현재의 값이 돌려주어진다.<br />
덧붙여count하지만 「1」의 경우는 호출해 회수가0에 리셋트 되어 「0」의 경우는 카운트를 늘린 다음 통산의 호출 회수가 돌려주어져 「-1」의 경우는 카운트를 늘리지 않고 호출 회수가 돌려주어진다.
</p>


<pre>
if(1=MG_Counter("",3)){
	;3의 배수+1번째의 호출
}else if(2=MG_Counter("",-3)){
	;3의 배수+2번째의 호출
}else{
	;3의 배수 번째의 호출
}
</pre>





<a name="script"></a><h2>스크립트에 의한 커스터마이즈</h2>
<a name="include"></a><h3>타스크립트에의#Include에 의한 편입</h3>
<p>
#Include그리고 다른 스크립트에 짜넣는 경우는, 조입처 스크립트와 같은 폴더에
모든 파일·폴더를 둘 필요가 있다.<br />
또,MouseGesture.ahk의 초기 처리가 실행되도록(듯이),#Include의 행을 기동시에 통과하는 위치에 쓰는지, 기동시에 실행되는 개소에서 「Gosub,MG_Init」(을)를 실행하는 것.
</p>
<p>
덧붙여 설정 화면의 「트레이 메뉴를 부메뉴화」에 체크를 넣고, 「MG_MenuParent」변수에 메뉴명을 격납하고 나서MouseGesture.ahk의 초기 처리를 실행하면, 지정한 메뉴내에MouseGesture.ahk의 부메뉴가 추가된다.
</p>


<a name="hotkey"></a><h3>메뉴의 커멘드를 hot key등에서 실행</h3>
<p>
메뉴 커멘드에 할당할 수 있고 있는 써브루틴은, 각각 이하와 같은 이름이 되어 있다.<br />
hot key로부터GoSub그리고 호출하는 등 하면, 잘 사용하는 기능을 재빠르게 실행 당한다.
</p>

<dl>
<dt>MG_NaviToggleEnable</dt><dd>네비 표시의ON/OFF</dd>
<dt>MG_Enable</dt><dd>개시 방아쇠의 유효화</dd>
<dt>MG_Disable</dt><dd>개시 방아쇠 무효화</dd>
<dt>MG_ToggleEnable</dt><dd>개시 방아쇠의 유효/무효 변환</dd>
<dt>MG_Edit</dt><dd>설정 화면 표시</dd>
<dt>MG_EditUser</dt><dd>MG_User.ahk편집</dd>
<dt>MG_Reload</dt><dd>정의 스크립트를 재생성 후, 스크립트를 재기동</dd>
</dl>



<a name="userahk"></a><h3>확장 스크립트</h3>
<img src="0220.png" width="412" height="322" alt="(8902bytes)">
<p>
조건 정의의 커스텀 조건식이나, 동작 할당의 스크립트에는, 함수나 써브루틴은 기술할 수 없다.<br />
조건 정의로 복잡한 판정 처리를 실시하고 싶은 경우나, 동작으로서 pop-up menu의 표시나 타이머 할당등을 사용하고 싶은 경우는, 스크립트의 다른 장소에 기술하는 일이 된다.<br />
이러한 스크립트를 기술하기 위해서, 「확장 스크립트」가 준비되어 있다.<br />
task tray 메뉴의 「확장 스크립트 편집」을 실행하면, 텍스트 문자 편집기로 스크립트(MG_User.ahk)하지만 열린다.
</p>
<p>
「초기화 처리」안에는, pop-up menu의 생성 등, 스크립트 기동시에 실행시키고 싶은 처리를 기술한다.<br />
「써브루틴 정의」에는, 함수나 그 외의 써브루틴을 기술한다.
</p>
<p>
다른 스크립트를#include그리고 짜넣고 싶은 경우는, 스크립트의 사용에 따르고, 적절한 분에게 기술한다.<br />
초기화 처리와 써브루틴 정의의 양쪽 모두가 있는 스크립트는,MG_User.ahk(와)과 같이 써브루틴 정의 부분을Goto그리고 뛰어넘도록(듯이) 하고, 초기화 처리 부분에 짜넣을 필요가 있다.

<br clear="all" />


<a name="tooltip"></a><h3>커스텀 툴 팁</h3>
<p>
통상, 「네비 표시」를 유효하게 하고 있으면, 입력중의 제스 차 문자열이 표시되지만, 미리 설정한 텍스트를 표시하는 일도 할 수 있다.<br />
조작 할당등의 메모를 표시하는데 사용한다.<br />
「RB_」 상태가 되었을 때에 표시되는 텍스트를 설정하려면 ,MG_User.ahk에 이하와 같이 기술한다.<br />
덧붙여 「화살표 네비」는OFF(으)로 해 둘 필요가 있다.
</p>
<pre>
MG_Tooltip_RB_=
(
　　아 아 아
　　　　↑
좋은 있어←　→우우
　　　　↓
　　예 예 예네
)
</pre>

<p>
조건에 따라 표시되는 텍스트를 바꾸고 싶은 경우에는, 제스 차의 동작 할당해에 이하와 같이 기술한다.<br />
이것은 「MG_CommandLine()」등의 정보를 표시하는데도 이용할 수 있다.<br />
제스 차의 인식이 종료하면 툴 팁은 사라지므로, 「RB_」 등 버튼을 누르고 있는 동안에 발동하는 제스 차에 할당할 필요가 있다.
</p>
<pre>
MG_Tooltip=
(
　　아 아 아
　　　　↑
좋은 있어←　→우우
　　　　↓
　　예 예 예네
)
MG_Wait()
</pre>




<div class="navi">→ <a target=_top href='../../index.html'>AutoHotkey(을)를 유행시키는 페이지</a> → <a target=_top href='../../myscripts/index.html'>My Scripts</a> → <a target=_top href='../../myscripts/mousegesture/index.html'>MouseGesture.ahk</a></div>


</body>


</html>